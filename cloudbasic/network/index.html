<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Network - LaMelD&#39;s dev Story</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://lameld.github.io/favicon.png">

  
  
  <link rel="stylesheet" href="/css/style.min.6aa5eecd4ca7c47fb2ca9b0775a7bd787e3e64a2eadf0fef8c9f924498f49127.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-kakao">
      <a href="/kakao/">
        <span>Kakao</span>
      </a>
    </li>
    
    <li class="menu-item-swea">
      <a href="/swea/">
        <span>Swea</span>
      </a>
    </li>
    
    <li class="menu-item-datastructure">
      <a href="/datastructure/">
        <span>DataStructure</span>
      </a>
    </li>
    
    <li class="menu-item-cloudbasic">
      <a href="/cloudbasic/">
        <span>CloudBasic</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://lameld.github.io"><img alt="Logo" src="/images/logo.svg" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://lameld.github.io"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-kakao">
      <a href="/kakao/">
        <span>Kakao</span>
      </a>
    </li>
    
    <li class="menu-item-swea">
      <a href="/swea/">
        <span>Swea</span>
      </a>
    </li>
    
    <li class="menu-item-datastructure">
      <a href="/datastructure/">
        <span>DataStructure</span>
      </a>
    </li>
    
    <li class="menu-item-cloudbasic">
      <a href="/cloudbasic/">
        <span>CloudBasic</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>


    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <h4>Cloudbasic</h4>
  <ul>
    
    <li class="active ">
      <a href="https://lameld.github.io/cloudbasic/network/">Network</a>
    </li>
    
    <li class="">
      <a href="https://lameld.github.io/cloudbasic/network_device/">Network Device</a>
    </li>
    
    <li class="">
      <a href="https://lameld.github.io/cloudbasic/linux_basic/">Linux Basic</a>
    </li>
    
    <li class="">
      <a href="https://lameld.github.io/cloudbasic/linux/">Linux</a>
    </li>
    
  </ul>
</div>

          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Network</h1>
<div class="content ">
  <h3 id="191230-monday--200103-friday">191230 Monday ~ 200103 Friday</h3>
<hr>
<h2 id="1-기본적으로-알아야-할-컴퓨터-기초">1. 기본적으로 알아야 할 컴퓨터 기초</h2>
<ul>
<li>데이터 표현
<ul>
<li>2진법, 10진법, 16진법(0x00)</li>
</ul>
</li>
<li>HW 구성요소
<ul>
<li>CPU(central processing unit)
<ul>
<li>processor : 물리적 코어</li>
</ul>
</li>
<li>RAM(memory : random access memory) : 주 기억
<ul>
<li>process : 실행되고 있는 프로그램</li>
</ul>
</li>
<li>하드 디스크(SSD/HDD) : 보조 기억</li>
<li>I/O 장치</li>
</ul>
</li>
<li>운영 체제(OS : operating system)
<ul>
<li>하드웨어를 관리해주는 프로그램</li>
<li>구성요소 : 커널, 쉘, 응용 프로그램</li>
</ul>
</li>
<li>파일의 특징
<ul>
<li>파일의 이름(확장자)
<ul>
<li>exe, txt, zip, egg, etc. -&gt; 4D 5A -&gt; 윈도우에서 실행파일 일 경우 binary의 시작</li>
</ul>
</li>
<li>파일의 경로
<ul>
<li>다양하게 지정할 수 있는 파일의 경로</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-vmwareworkstation--가상화에-관련된-회사-이름">2. VMware(workstation) : 가상화에 관련된 회사 이름</h2>
<ul>
<li>정의
<ul>
<li>하이퍼바이저 기반 가상 머신 소프트웨어</li>
</ul>
</li>
<li>하이퍼바이저
<ul>
<li>가상 머신을 만들어주는 프로그램</li>
<li>HOST에서 GUEST를 만들어주는 프로그램</li>
<li>현재 사용하려는 workstation이 하이퍼바이저</li>
</ul>
</li>
<li>실습
<ul>
<li>vmware 설치</li>
<li>가상 머신 생성</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-네트워크">3. 네트워크</h2>
<ul>
<li>정의
<ul>
<li>노드들이 데이터를 공유할 수 있게 하는 디지털 전기 통신망의 하나이다.</li>
<li>분산되어 있는 컴퓨터를 통신망으로 연결한 것을 말한다.</li>
<li>네트워크에서 여러 장치들은 노드 간 연결을 사용하여 서로에게 데이터를 교환한다.</li>
<li>*노드 : 네트워크에 속한 컴퓨터 또는 통신 장비</li>
<li>네트워크? 인터넷? www?<br>
가장 큰 네트워크 인터넷<br>
www : world wide WEB</li>
</ul>
</li>
<li>분류
<ul>
<li>크기에 따른 분류
<ul>
<li>LAN, WAN, MAN, 기타</li>
<li>LAN : 가까운 지역을 하나로</li>
<li>WAN : 멀리 있는 지역을 하나로</li>
</ul>
</li>
<li>연결 형태에 따른 분류
<ul>
<li>Star 형 : 중앙 장비에 모든 노드가 연결된 형태</li>
<li>Mesh 형 : 여러 노드들이 서로 그물처럼 연결된 형태</li>
<li>혼합형(Star + Mesh)</li>
</ul>
</li>
</ul>
</li>
<li>통신 방식
<ul>
<li>유니 캐스트 : 1:1 통신</li>
<li>멀티 캐스트 : 1:다수 통신</li>
<li>브로드 캐스트 : 같은 네트워크(Local)에 있는 모든 대상에게 통신</li>
</ul>
</li>
<li>프로토콜
<ul>
<li>정의 : 일종의 양식, 네트워크에서 노드와 노드가 통신할 때 어떤 노드가 어느 노드에게 어떤 데이터를 보내는지 작성하기위한 양식</li>
<li>가까운 곳으로 통신 : Ethernet 프로토콜(MAC 주소)</li>
<li>멀리 있는 곳으로 통신 : ICMP, IPv4, ARP(IP 주소)</li>
<li>여러가지 프로그램으로 통신 : TCP, UDP(port 번호)</li>
<li>여러 프로토콜들로 캡슐화 된 패킷(Ethernet/IPv4/TCP/데이터)</li>
</ul>
</li>
<li>실습
<ul>
<li>tracert [ip or address] : 네트워크 경로 추적<br>
네트워크 장비 30개 이하로 연결되어 있다(30홉 이하)</li>
<li>wireshark : 네트워크 패킷을 볼 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="4-네트워크-모델">4. 네트워크 모델</h2>
<p><img src="/images/net_2/osi7.PNG" alt="IMAGE"></p>
<p><img src="/images/net_2/osi.png" alt="IMAGE"></p>
<ul>
<li>TCP/IP, OSI 7</li>
<li>TCP/IP (4계층)</li>
<li>OSI 7 Layer (7계층) - 표준
<ul>
<li>응용			http</li>
<li>표현</li>
<li>세션</li>
<li>전송			TCP, UDP</li>
<li>네트워크		IP, ICMP, ARP</li>
<li>데이터 링크	이더넷</li>
<li>물리</li>
</ul>
</li>
<li>비교
<ul>
<li>공통
<ul>
<li>계층적 네트워크 모델</li>
<li>계층간 역할 정의</li>
</ul>
</li>
<li>차이
<ul>
<li>계층의 수 차이</li>
<li>OSI는 역할 기반, TCP/IP는 프로토콜 기반</li>
<li>OSI는 통신 전반에 대한 표준</li>
<li>TCP/IP는 데이터 전송기술 특화</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-네트워크를-통해-전달되는-데이터-패킷---encapsulation-decapsulation">5. 네트워크를 통해 전달되는 데이터, 패킷 - encapsulation, decapsulation</h2>
<ul>
<li>정의
<ul>
<li>네트워크 상에서 전달되는 데이터를 통칭하는 말로 네트워크에서 전달하는 데이터의 형식화된 블록. 패킷은 제어 정보와 사용자 데이터로 이루어지며 사용자 데이터는 페이로드라고도 한다.</li>
<li>패킷 (헤더/페이로드/풋터)</li>
<li>여러가지 프로토콜들로 캡슐화 된 패킷(encapsulation)
<ul>
<li>encapsulation 과정은 ppt에서 발췌</li>
<li>상위 계층에서 하위 계층으로 내려간다.</li>
</ul>
</li>
<li>encapsulation(보낼 때) &lt;==&gt; decapsulation(받을 때)</li>
</ul>
</li>
</ul>
<p><img src="/images/net_2/encap.PNG" alt="IMAGE"></p>
<p><img src="/images/net_2/decap.PNG" alt="IMAGE"></p>
<h2 id="6-osi7layer---2계층--데이터-링크">6. OSI7layer - 2계층 :: 데이터 링크</h2>
<ul>
<li>기능
<ul>
<li>하나의 네트워크 대역 즉, 같은 네트워크 상에 존재하는 여러 장비들 중에서 어떤 장비가 어떤 장비에게 보내는 데이터를 전달, 오류제어와 흐름제어 수행</li>
</ul>
</li>
<li>네트워크 크기
<ul>
<li>하나의 네트워크 대역 LAN에서만 통신할 때 사용한다.</li>
<li>다른 네트워크와 통신 할 때는 항상 3계층의 도움이 필요하다.</li>
</ul>
</li>
<li>2계층에서 사용하는 주소 : MAC 주소(물리적 주소)
<ul>
<li>ppt에서 이미지 발췌</li>
</ul>
</li>
<li>2계층의 프로토콜 : Ethernet
<ul>
<li>Destination Address(6byte : 목적지) + Source Address(6byte : 출발지) + Ethernet Type(2byte : 타입) + 페이로드</li>
<li>상위 프로토콜이 ipv4라면 Ethernet Type : 0800</li>
<li>상위 프로토콜이 ARP라면 Ethernet Type : 0806</li>
</ul>
</li>
</ul>
<p><img src="/images/net_3/ethernet_protocol.PNG" alt="IMAGE"></p>
<h2 id="7-osi7layer---3계층--네트워크">7. OSI7layer - 3계층 :: 네트워크</h2>
<ul>
<li>
<p>기능</p>
<ul>
<li>다른 네트워크 대역 즉, 멀리 떨어진 곳에 존재하는 네트워크까지 어떻게 데이터를 전달할지 제어하는 일을 담당</li>
<li>발신에서 착신까지의 패킷의 경로를 제어</li>
</ul>
</li>
<li>
<p>IP주소를 사용 -&gt; IPv4, 서브넷 마스크, 게이트웨이 필요(멀리있는 곳과 통신하기위한 기본 설정)</p>
</li>
<li>
<p>3계층 프로토콜</p>
<ul>
<li>ARP 프로토콜</li>
<li>IPv4 프로토콜</li>
<li>ICMP 프로토콜</li>
</ul>
</li>
<li>
<p>일반적인 IP 주소 (classful, classless)</p>
<ul>
<li>A클래스, B클래스, C클래스, D클래스, E클래스</li>
</ul>
</li>
<li>
<p>서브넷 마스크(서브넷팅 &lt;==&gt; 슈퍼네팅)</p>
<ul>
<li>클래스풀한 네트워크 대역을 나눠주는데 사용하는 값</li>
<li>어디까지가 네트워크 대역을 구분하는데 사용하고 어디서부터 호스트를 구분하는데 사용하는지 지정</li>
<li>1로 시작, 1과 1사이에는 0이 올 수 없음</li>
</ul>
</li>
<li>
<p>사설 IP와 공인 IP (+ classful = 현재 사용되고 있는 IPv4)</p>
<p><img src="/images/net_3/privat_public_IP.PNG" alt="IMAGE"></p>
<ul>
<li>NAT(IP를 바꾸는 기술) : 사설 IP =&gt; 공인 IP OR 공인 IP =&gt; 사설 IP</li>
<li>port forwarding</li>
</ul>
</li>
<li>
<p>특수 IP</p>
<ul>
<li>0.0.0.0 : wildcard</li>
<li>127.0.0.x : 본인</li>
<li>게이트웨이 주소 : 쓸 수 있는 ip중에 가장 작거나 큰 ip 주소(작은 것을 쓰는 경우가 많다)</li>
</ul>
</li>
</ul>
<h2 id="8-네트워크-subneting---가용한-ip를-구하기-위해-작업을-진행한다">8. 네트워크 Subneting -&gt; 가용한 IP를 구하기 위해 작업을 진행한다.</h2>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">1) 네트워크 ID와 서브넷 마스크를 2진수로 변경
2) 서브넷 마스크를 1씩 증가시키면서 네트워크를 쪼갠다
3) 네트워크 ID에서 서브넷 마스크가 증가한 부분을 1로 꽉 찰때까지 1씩 증가시킨다
4) 쪼개진 각각의 네트워크의 네트워크 ID는 1씩 증가시킨 값 그대로
5) 쪼개진 각각의 네트워크의 브로드캐스트 주소는 뒷 부분을 전부 1로 채운다
6) 각 네트워크에서 사용 가능한 IP주소의ㅡ 범위는 네트워크 ID + 1, 브로드캐스트 주소 - 1
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">1. 211.100.10.0/24  네트워크를 각 네트워크 당 60개의 HOST가 사용할 수 있도록 subneting

네트워크 ID 0 : 	11010011.01100100.00001010.00 000000
네트워크 ID 1 : 	11010011.01100100.00001010.01 000000
네트워크 ID 2 : 	11010011.01100100.00001010.10 000000
네트워크 ID 3 : 	11010011.01100100.00001010.11 000000
서브넷 마스크 : 	11111111.11111111.11111111.11 000000

1) subnet mask : 11111111.1111111.11111111.11000000, /26
2) subnet 개수 : 4개
3) HOST의 개수 : 64개
4) 마지막 subnet의 Network-ID : 211.100.10.192
5) 첫번째 subnet의 broadcast 주소 : 211.100.10.63
6) 두번째 subnet의 사용 가능한 IP 범위 : 211.100.10.65 ~ 211.100.10.126
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">2. 195.168.12.0/24 네트워크를 8개의 네트워크로 사용할 수 있도록 subneting

네트워크 ID 0 :		11000011.10101000.00001100.000 00000
네트워크 ID 1 :		11000011.10101000.00001100.001 00000
네트워크 ID 2 :		11000011.10101000.00001100.010 00000
네트워크 ID 3 :		11000011.10101000.00001100.011 00000
네트워크 ID 4 :		11000011.10101000.00001100.100 00000
네트워크 ID 5 :		11000011.10101000.00001100.101 00000
네트워크 ID 6 :		11000011.10101000.00001100.110 00000
네트워크 ID 7 :		11000011.10101000.00001100.111 00000
서브넷 마스크 :		11111111.11111111.11111111.111 00000

	네트워크 ID	    브로드캐스트주소	 범위
0번	195.168.12.0	195.168.12.31		195.168.12.1 ~ 195.168.12.32
1번	195.168.12.32	195.168.12.63		195.168.12.33 ~ 195.168.12.62
2번	195.168.12.64	195.168.12.95		195.168.12.65 ~ 195.168.12.94
3번	195.168.12.96	195.168.12.127		195.168.12.97 ~ 195.168.12.126
4번	195.168.12.128	195.168.12.159		195.168.12.129 ~ 195.168.12.158
5번	195.168.12.160	195.168.12.191		195.168.12.161 ~ 195.168.12.190
6번	195.168.12.192	195.168.12.223		195.168.12.193 ~ 195.168.12.222
7번	195.168.12.224	195.168.12.255		195.168.12.225 ~ 195.168.12.254
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">3. 152.0.61.0/24 네트워크를 각 네트워크 당 100개의 HOST가 사용할 수 있도록 subneting

152.0.61.0/25	152.0.1.127
152.0.61.128/25	152.0.1.255
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">4. 189.101.7.0/24 네트워크를 각 네트워크 당 50개의 Host가 사용할 수 있도록 subnetiing
	네트워크 ID		    브로드캐스트주소	 범위
0번	189.101.7.0/26		189.101.7.63/26		189.101.7.1/26 ~ 189.101.7.62/26
1번	189.101.7.64/26		189.101.7.127/26	189.101.7.65/26 ~ 189.101.7.126/26
2번	189.101.7.128/26	189.101.7.191/26	189.101.7.129/26 ~ 189.101.7.190/26
3번	189.101.7.192/26	189.101.7.255/26	189.101.7.193/26 ~ 189.101.7.254/26
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">5. 206.81.128.0/18 네트워크를 8개의 네트워크로 사용할 수 있도록 subneting
206     .81      .10 000 000.00000000
206     .81      .10 001 000.00000000
206     .81      .10 010 000.00000000
206     .81      .10 011 000.00000000
206     .81      .10 100 000.00000000
206     .81      .10 101 000.00000000
206     .81      .10 110 000.00000000
206     .81      .10 111 000.00000000
11111111.11111111.11 111 000.00000000

	네트워크 ID		    브로드캐스트주소	 범위
0번	206.81.128.0		206.81.135.255		206.81.128.1 ~ 206.81.135.254
1번	206.81.136.0		206.81.143.255		206.81.136.1 ~ 206.81.143.254
2번	206.81.144.0		206.81.151.255		206.81.144.1 ~ 206.81.151.254
3번	206.81.152.0		206.81.159.255		206.81.152.1 ~ 206.81.159.254
4번	206.81.160.0		206.81.167.255		206.81.160.1 ~ 206.81.167.254
5번	206.81.168.0		206.81.175.255		206.81.168.1 ~ 206.81.175.254
6번	206.81.176.0		206.81.183.255		206.81.176.1 ~ 206.81.183.254
7번	206.81.184.0		206.81.191.255		206.81.184.1 ~ 206.81.191.254
</code></pre></div><h2 id="9-3계층-프로토콜---arp">9. 3계층 프로토콜 - ARP</h2>
<ul>
<li>
<p>ARP가 하는일</p>
<ul>
<li>같은 네트워크 대역에서 통신을 하기위해 필요한 MAC주소를 IP주소를 이용해서 알아오는 프로토콜이다.</li>
<li>같은 네트워크 대역에서 통신을 한다고 하더라도 데이터를 보내기 위해서는 7계층부터 캡슐화를 통해 데이터를 보내기 때문에 IP주소와 MAC주소가 모두 필요하다. 이때 IP주소는 알고 MAC주소는 모르더라도 ARP를 통해 통신이 가능하다.</li>
<li>보안상 중요하다.</li>
</ul>
</li>
<li>
<p>프로토콜 구조</p>
<p><img src="/images/net_3/ARP_protocol.PNG" alt="IMAGE"></p>
<ul>
<li>ARP에서 opcode는 요청인지 응답인지만 판단한다.
<ul>
<li>0x0001 : 요청</li>
<li>0x0002 : 응답</li>
</ul>
</li>
</ul>
</li>
<li>
<p>통신 과정</p>
<ul>
<li>ARP 프로토콜을 채워주고 destination MAC 주소를 0으로 초기화 한다.</li>
<li>encapsulation을 진행하는 과정에서 destination을 F로 초기화 하여 broadcast를 설정하여 모든 곳(같은 네트워크 대역의)에 보낸다.</li>
<li>스위치에서는 ARP를 까보지 않는다.</li>
<li>받은 곳에서 ARP를 까보고 본인에게 보낸 것이 맞는지 확인한다.</li>
<li>IP주소가 일치하는곳에서 RESPONSE를 보낸다.</li>
<li>RESPONSE과정은 encapsulation을 실시하여 진행한다.</li>
</ul>
</li>
<li>
<p>프레임의 최소 최대 단위(참고)</p>
<ul>
<li>최소 60 Byte</li>
<li>최대 1514 Byte</li>
</ul>
</li>
<li>
<p>실습 : wireshark</p>
<p><img src="/images/net_3/wireshark_request_reply.PNG" alt="IMAGE"></p>
<ul>
<li>ARP 프로토콜을 사용해서 스니핑이 가능하다.
- 어태커가 게이트웨이인 것처럼 속여(arp 캐시 테이블에 접근하여 속인다) 스니핑을 할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="10-3계층-프로토콜---ipv4-icmp">10. 3계층 프로토콜 - IPv4, ICMP</h2>
<ul>
<li>
<p>IPv4 Protocol</p>
<ul>
<li>
<p>네트워크 상에서 데이터를교화하기 위한 프로토콜</p>
</li>
<li>
<p>데이터가 <em><strong>정확하게 전달될 것을 보장하지 않는다.</strong></em></p>
</li>
<li>
<p>중복된 패킷을 전달하거나 패킷의 순서를 잘못 전달할 가능성도 있다.(악의적으로 이용되면 DoS 공격이 됨)</p>
</li>
<li>
<p>데이터의 정확하고 순차적인 전달은 그보다 상위 프로토콜인 TCP에서 보장함.</p>
</li>
<li>
<p>프로토콜 구조</p>
<p><img src="/images/net_3/IPv4_protocol.PNG" alt="IMAGE"></p>
<ul>
<li>version : IPv4 이므로 4</li>
<li>IHL : 20 / 4 = 5 로 설정(바이트 단위)</li>
<li>Type Of Service : 현재는 사용하지 않음(0으로 설정)</li>
<li>Total Length : 페이로드 포함 전체 길이</li>
<li>Identification : 식별자</li>
<li>flag : 3bit
<ul>
<li>0번 : 안씀</li>
<li>1번 : 쪼개지 않고 보내겠다(최대 전송 단위 : 1500Byte)</li>
<li>2번 : 쪼개서 보내겠다.</li>
<li>010 으로 최대 전송단위를 넘는다면 전송되지 않는다.</li>
</ul>
</li>
<li>Fragment Offset : 쪼개서 보내져 받았을 때 순서를 알 수 있게하기 위해서 시작부분에서 얼마나 떨어져 있는지 알려준다.</li>
<li>Time to live : DeadLock을 방지하기 위해서 설정
<ul>
<li>윈도우는 128로 설정</li>
<li>리눅스는 32로 설정</li>
</ul>
</li>
<li>protocol : 상위 프로토콜이 무엇인지 알 수 있음(확인이 필요하다)
<ul>
<li>TCP(6), UDP(17), ICMP(1)</li>
</ul>
</li>
<li>Header Checksum : 윗 부분을 본인이 계산하고 받은것과 대조하여 다른 부분이 있는지 확인</li>
</ul>
</li>
<li>
<p>보내는 Offset을 변경하여 DoS공격을 할 수 있다.</p>
</li>
</ul>
</li>
<li>
<p>ICMP Protocol</p>
<ul>
<li>
<p>Internet Control Message Protocol</p>
</li>
<li>
<p>네트워크 컴퓨터 위에서 돌아가는 운영체제에서 __오류메시지__를 전송 받는 데 주로 쓰인다.</p>
</li>
<li>
<p>프로토콜 구조의 Type과 Code를 통한 오류 메시지를 전송 받는다.</p>
</li>
<li>
<p>프로토콜 구조</p>
<p><img src="/images/net_3/ICMP_protocol.PNG" alt="IMAGE"></p>
<ul>
<li>Type
<ul>
<li>8 : 요청</li>
<li>0 : 응답</li>
<li>3 : ?</li>
<li>5 : ?</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>라우팅 테이블&hellip;?</p>
<ul>
<li>어디로 보내야 하는지 설정되어 있는 테이블</li>
<li>지도가 있어야 찾을 수 있다.</li>
<li>모르는 곳에 가야한다면 0.0.0.0을 통해서 나간다(게이트웨이)</li>
</ul>
</li>
<li>
<p>MAC address를 알지 못한다면 APR 프로토콜을 사용하여 MAC address를 알아낸다.(ARP 캐시 테이블, 라우팅 테이블 완성?)</p>
</li>
<li>
<p>다른 네트워크와 통신하는 과정</p>
</li>
</ul>
<p><img src="/images/net_3/ping.PNG" alt="IMAGE"></p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">	- encapsulation start
	icmp request
	0800 4d56 0001 0001

	ipv4
	4500 003c 12ab 0000 0801 0000 c0a8 0a0a c0a8 1414

	ethernet
	cccc cccc cccc aaaa aaaa aaaa 0800 (receive mac / send mac / ethernet)
	- encapsulation end

	ethernet
	2222 2222 2222 1111 1111 1111 0800

	ethernet
	4444 4444 4444 3333 3333 3333 0800

	- decapsulation start
	ethernet
	bbbb bbbb bbbb dddd dddd dddd 0800

	ipv4
	4500 003c 12ab 0000 0801 0000 c0a8 0a0a c0a8 1414

	icmp request
	0800 4d56 0001 0001
	- decasulation end

	- encapsulation start
	icmp reply
	0800 4d56 0001 0001

	ipv4
	4500 003c 12ab 0000 8001 0000 c0a8 1414 c0a8 0a0a

	ethernet
	dddd dddd dddd bbbb bbbb bbbb 0800 (receive mac / send mac / ethernet)
	- encapsulation end

	이후 생략...
</code></pre></div><h2 id="11-3계층-프로토콜---ipv4의-조각화">11. 3계층 프로토콜 - IPv4의 조각화</h2>
<ul>
<li>정의
<ul>
<li>큰 IP 패킷들이 적은 <strong>MTU</strong>(Maximum Transmission Unit : 일반적으로 1500 Byte)를 갖는 링크를 통하여 전송되려면 <strong>여러 개의 작은 패킷으로 쪼개어/조각화 되어 전송</strong>되어야 한다.</li>
<li>목적지까지 패킷을 전달하는 과정에 통과하는 각 라우터마다 전송에 적합한 프레임으로 변환이 필요하다.</li>
<li>일단 조각화되면, 최종 목적지에 도달할 때 까지 재조립도디지 않는 것이 일반적</li>
<li>IPv4에서는 발신지 뿐만 아니라 중간 라우터에서도 IP 조각화가 가능</li>
<li>IPv6에서는 IP단편화가 발신지에서만 가능</li>
<li>재조립은 항상 최종 수신지에서만 가능하다.</li>
</ul>
</li>
<li>IPv4(20 Byte) + 페이로드 &lt;= MTU</li>
<li>식별자(identification)은 동일하게 한다.</li>
</ul>
<p><img src="/images/net_3/fragmentalize.PNG" alt="IMAGE"></p>
<ul>
<li>
<p>ICMP는 마지막에만 붙인다.</p>
</li>
<li>
<p>라우팅 테이블 :: netstat -r</p>
</li>
<li>
<p>Offset = 페이로드 / 8 : 한정된 크기에서 큰 값을 표현하기 위하여</p>
</li>
<li>
<p>예제</p>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">1. 전송하려는 데이터 크기 [8937] 바이트
MTU [2300]바이트

데이터를 [2300] - 20 = [2280] 씩 조각화
	MTU	 IPv4
</code></pre></div><table>
<thead>
<tr>
<th align="right">패킷</th>
<th align="center">플래그</th>
<th align="right">오프셋(크기/8)</th>
<th align="right">데이터크기</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0번</td>
<td align="center">1</td>
<td align="right">0</td>
<td align="right">2280</td>
</tr>
<tr>
<td align="right">1번</td>
<td align="center">1</td>
<td align="right">285</td>
<td align="right">2280</td>
</tr>
<tr>
<td align="right">2번</td>
<td align="center">1</td>
<td align="right">570</td>
<td align="right">2280</td>
</tr>
<tr>
<td align="right">3번</td>
<td align="center">0</td>
<td align="right">855</td>
<td align="right">2097</td>
</tr>
</tbody>
</table>
<p>마지막 패킷의 페이로드 크기 : 2105 (ICMP + 데이터)</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">2. 전송하려는 데이터 크기 [2379] 바이트
MTU [980]바이트


데이터를 [980] - 20 = [960] 씩 조각화
	MTU	 IPv4
</code></pre></div><table>
<thead>
<tr>
<th align="right">패킷</th>
<th align="center">플래그</th>
<th align="right">오프셋(크기/8)</th>
<th align="right">데이터크기</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0번</td>
<td align="center">1</td>
<td align="right">0</td>
<td align="right">960</td>
</tr>
<tr>
<td align="right">1번</td>
<td align="center">1</td>
<td align="right">120</td>
<td align="right">960</td>
</tr>
<tr>
<td align="right">2번</td>
<td align="center">1</td>
<td align="right">240</td>
<td align="right">960</td>
</tr>
<tr>
<td align="right">3번</td>
<td align="center">0</td>
<td align="right">360</td>
<td align="right">459</td>
</tr>
</tbody>
</table>
<p>마지막 패킷의 페이로드 크기 : 467 (ICMP + 데이터)</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">3. 전송하려는 데이터 크기 [4618] 바이트
MTU [1370]바이트

데이터를 [1370] - 20 = [1350] 씩 조각화
	MTU	 IPv4
</code></pre></div><table>
<thead>
<tr>
<th align="right">패킷</th>
<th align="center">플래그</th>
<th align="right">오프셋(크기/8)</th>
<th align="right">데이터크기</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0번</td>
<td align="center">1</td>
<td align="right">0</td>
<td align="right">1350</td>
</tr>
<tr>
<td align="right">1번</td>
<td align="center">1</td>
<td align="right">?</td>
<td align="right">1350</td>
</tr>
<tr>
<td align="right">2번</td>
<td align="center">1</td>
<td align="right">?</td>
<td align="right">1350</td>
</tr>
<tr>
<td align="right">3번</td>
<td align="center">0</td>
<td align="right">?</td>
<td align="right">568</td>
</tr>
</tbody>
</table>
<p>마지막 패킷의 페이로드 크기 : 576 (ICMP + 데이터)</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">4. 전송하려는 데이터 크기 [4800] 바이트
MTU [1500]바이트

데이터를 [1500] - 20 = [1480] 씩 조각화
	MTU	 IPv4
</code></pre></div><table>
<thead>
<tr>
<th align="right">패킷</th>
<th align="center">플래그</th>
<th align="right">오프셋(크기/8)</th>
<th align="right">데이터크기</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0번</td>
<td align="center">1</td>
<td align="right">0</td>
<td align="right">1480</td>
</tr>
<tr>
<td align="right">1번</td>
<td align="center">1</td>
<td align="right">185</td>
<td align="right">1480</td>
</tr>
<tr>
<td align="right">2번</td>
<td align="center">1</td>
<td align="right">370</td>
<td align="right">1480</td>
</tr>
<tr>
<td align="right">3번</td>
<td align="center">0</td>
<td align="right">555</td>
<td align="right">360</td>
</tr>
</tbody>
</table>
<p>마지막 패킷의 페이로드 크기 : 368 (ICMP + 데이터)</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">5. 전송하려는 데이터 크기 [4432] 바이트
MTU [1500]바이트

데이터를 [1500] - 20 = [1480] 씩 조각화
	MTU	 IPv4
</code></pre></div><table>
<thead>
<tr>
<th align="right">패킷</th>
<th align="center">플래그</th>
<th align="right">오프셋(크기/8)</th>
<th align="right">데이터크기</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0번</td>
<td align="center">1</td>
<td align="right">0</td>
<td align="right">1480</td>
</tr>
<tr>
<td align="right">1번</td>
<td align="center">1</td>
<td align="right">185</td>
<td align="right">1480</td>
</tr>
<tr>
<td align="right">2번</td>
<td align="center">1</td>
<td align="right">370</td>
<td align="right">1472</td>
</tr>
</tbody>
</table>
<p>마지막 패킷의 페이로드 크기 : 1480 (ICMP + 데이터)</p>
<h2 id="12-osi7layer---4계층--전송">12. OSI7layer - 4계층 :: 전송</h2>
<ul>
<li>
<p>전송 계층</p>
<ul>
<li>송신자의 <strong>프로세스</strong>와 수신자의 <strong>프로세스를 연결하는 통신 서비스</strong>를 제공한다.</li>
<li>전송 계층은 연결 지향 데이터 스트림 지원, 신뢰성, 흐름 제어, 그리고 다중화와 같은 편리한 서비스를 제공한다.</li>
<li>전송 프로토콜 중 가장 잘 알려진 것은 연결 지향 전송 방식을 사용하는 전송 제어 프로토콜(TCP)이다. 보다 단순한 전송에 사용되는 사용자 데이터그램 프로토콜(UDP)도 있다.</li>
</ul>
</li>
<li>
<p>종류 :: TCP, UDP</p>
<ul>
<li>TCP :: 상태가 있다
<img src="/images/net_3/TCP_protocol.PNG" alt="IMAGE"></li>
<li>UDP :: 상태가 없다(비연결형 서비스)
<img src="/images/net_3/UDP_protocol.PNG" alt="IMAGE"></li>
</ul>
</li>
<li>
<p>포트 번호(좀 더 자세한 학습이 필요하다)</p>
<ul>
<li>특정 프로세스와 특정 프로세스가 통신하기 위하여 사용한다.</li>
<li><strong>하나의 포트는 하나의 프로세스만</strong> 가능하다.</li>
<li>하나의 프로세스가 여러 개의 포트를 사용하는 것은 가능하다.</li>
<li>포트 번호는 일반적으로 정해져 있지만 <strong>무조건 지켜야 하는 것은 아니다.</strong></li>
<li>예를 들어 일반적으로 웹 서비스는 80번 포트를 사용하지만 웹 서비스가 항상 80번 포트를 사용해야만 하는 것은 아니다.</li>
</ul>
</li>
<li>
<p>Well-Known 포트, Registered 포트, Dynamic 포트 :: 절대적인 것은 아니다</p>
<ul>
<li><strong>Well-Known 포트</strong> :: 전 세계적으로 유명한
<img src="/images/net_3/wellknown_port.PNG" alt="IMAGE"></li>
<li>Registered 포트 :: 조금 유명한
<img src="/images/net_3/registered_port.PNG" alt="IMAGE"></li>
<li>Dynamic 포트 :: 일반 사용자들이 사용하는 
<img src="/images/net_3/dynamic_port.PNG" alt="IMAGE"></li>
</ul>
</li>
<li>
<p>netstat -ano :: PID 확인하기</p>
</li>
<li>
<p>서비스 :: 백그라운드에서 실행되는 프로그램</p>
</li>
<li>
<p>주소들의 사용(참고)</p>
<ul>
<li>MAC 주소
<ul>
<li>특정 컴퓨터를 컴퓨터가 찾아갈 때 사용하는 주소</li>
</ul>
</li>
<li>IP 주소
<ul>
<li>특정 네트워크 대역을 찾아가서 특정 컴퓨터를 찾아갈 때 사용하는 주소</li>
</ul>
</li>
<li>포트 번호
<ul>
<li>특저어 컴퓨터에서 동작하고 있는 특정 프로그램을 찾아가는 주소</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="13-비연결지향형-udp">13. 비연결지향형 UDP</h2>
<ul>
<li>
<p>하는 일</p>
<ul>
<li>사용자 데이터그램 프로토콜(User Datagram Protocol)은 유니버셜 데이터그램 프로토콜이라고도 한다.</li>
<li>UDP의 <strong>전송 방식은 너무 단순</strong>해서 서비스의 <strong>신뢰성이 낮고</strong>, 데이터그램 도착 순서가 바뀌거나, 중복되거나, 심지어는 통보 없이 누락시키기도 한다.</li>
<li>UDP는 일반적으로 <strong>오류의 검사와 수정이 필요 없는</strong> 프로그램에서 수행할 것으로 가정한다.</li>
</ul>
</li>
<li>
<p>구조</p>
<p><img src="/images/net_4/UDP.PNG" alt="IMAGE"></p>
</li>
<li>
<p>사용하는 프로그램</p>
<ul>
<li>DNS 서버</li>
<li>tftp 서버(파일전송 프로그램)</li>
</ul>
</li>
</ul>
<h2 id="14-연결지향형-tcp">14. 연결지향형 TCP</h2>
<ul>
<li>
<p>하는 일</p>
<ul>
<li>전송 제어 프로토콜(Transmission Control Protocol)은 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 통신을 <strong>안정적으로, 순서대로, 에러없이</strong> 교화할 수 있게 한다.</li>
<li>TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우 일반적으로 TCP 대신 비접속형 사용자 데이터그램 프로토콜(UDP)을 사용한다.</li>
<li>TCP는 UDP보다 안전하지만 느리다.</li>
</ul>
</li>
<li>
<p>구조
<img src="/images/net_4/TCP.PNG" alt="IMAGE">
<img src="/images/net_4/TCP_flag.PNG" alt="IMAGE"></p>
</li>
<li>
<p>TCP를 이용한 통신과정 :: 연결 수립 과정(3-Way-HandShake)</p>
<ul>
<li>TCP를 이용한 데이터 통신을 할 때 프로세스와 프로세스를 연결하기 위해 <strong>가장 먼저 수행되는 과정</strong></li>
</ul>
<ol>
<li>클라이언트가 서버에게 요청 패킷을 보내고</li>
<li>서버가 클라이언트의 요청을 받아들이는 패킷을 보내고</li>
<li>클라이언트는 이를 최종적으로 수락하는 패킷을 보낸다.
<img src="/images/net_4/TCP_3wayhandshake.PNG" alt="IMAGE"></li>
</ol>
<ul>
<li>SYN(sync), ACK(acknowledge)</li>
<li>a, b를 잘 봐야 한다.</li>
<li>패킷을 보내고 받는 과정에서 encapsulation(Send시 발생), decapsulation(receive시 발생)이 이루어진다.</li>
<li>알아보기 :: 세션 하이재킹 커넥션을 뺏어온다.</li>
</ul>
</li>
<li>
<p>TCP를 이용한 통신과정 :: 데이터 송수신 과정(HTTP, FTP와 같은 데이터를 포함한 통신)</p>
<ul>
<li>3 WAY HANDSHAKE 와 비슷한 과정을 거친다.</li>
<li>data의 크기에 따라서 ack의 크기가 바뀐다.</li>
</ul>
</li>
<li>
<p>TCP 상태전이도 :: LISTEN, ESTABLISHED</p>
<p><img src="/images/net_4/TCP_state.PNG" alt="IMAGE"></p>
<ul>
<li>LISTEN : connection을 할 준비가 되었다.</li>
<li>ESTABLISHED : 3 way handshake가 완료되어 통신할 준비가 되었다.</li>
</ul>
<p><img src="/images/net_4/TCP_3way.PNG" alt="IMAGE"></p>
</li>
</ul>
<h2 id="15-nat와-포트포워딩">15. NAT와 포트포워딩</h2>
<ul>
<li>
<p>NAT(Networt Address Translation) 정의</p>
<ul>
<li><strong>IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 말한다.</strong></li>
<li>패킷에 변화가 생기기 때문에 IP나 TCP/UDP의 Checksum도 다시 계산되어 재기록해야 한다.</li>
<li>NAT를 이용하는 이유는 대개 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위함이다.</li>
<li>하지만 꼭 사설 IP를 공인 IP로 변환하는데에만 사용하는 기술은 아니다.</li>
</ul>
<p><img src="/images/net_4/NAT.PNG" alt="IMAGE"></p>
</li>
<li>
<p>Port Forwarding(Port Mapping) 정의</p>
<ul>
<li>패킷이 라우터나 방화벽과 같은 네트워크 장비를 가로지르는 동안 <strong>특정 IP주소와 포트 번호의 통신 요청을 특정 다른 IP와 포트 번호로 넘겨주는</strong> 네트워크 주소 변환(NAT)의 응용이다.</li>
<li>이 기법은 게이트웨이의 반대쪽에 위치한 사설네트워크에 상주하는 호스트에 대한 서비스를 생성하기 위해 흔히 사용된다.</li>
</ul>
<p><img src="/images/net_4/port_forwarding.PNG" alt="IMAGE"></p>
</li>
</ul>
<h2 id="16-osi7layer---7계층--응용--http">16. OSI7layer - 7계층 :: 응용 :: HTTP</h2>
<ul>
<li>
<p>기본적인 부분</p>
<p><img src="/images/net_4/HTTP.PNG" alt="IMAGE"></p>
<ul>
<li>HTTP : 요청하고 받아오는 프로토콜</li>
<li>HTML, Javascript, CSS : 웹의 틀, Client</li>
<li>ASP/ASP.NET, JSP, PHP : 웹 서버 페이지를 만드는 기술, Server</li>
</ul>
</li>
<li>
<p>HTTP(HyperText Transport Protocol)</p>
<ul>
<li>www에서 쓰이는 핵심 프로토콜로 문서의 전송을 위해 쓰이며, 오늘날 거의 모든 웹 애플리케이션에서 사용되고 있다.</li>
<li>Request / Response 동작에 기반하여 서비스 제공</li>
<li>HTTP 1.0 / HTTP 1.1
<ul>
<li>
<p>HTTP 1.0</p>
<ul>
<li>&ldquo;연결 수립, 동작, 연결 해제&quot;의 단순함이 특지이</li>
<li>단순 동작(연결 수립, 동작, 연결 해제)이 반복되어 통신 부하 문제 발생</li>
</ul>
<p><img src="/images/net_4/HTTP1_0.PNG" alt="IMAGE"></p>
</li>
<li>
<p>HTTP 1.1</p>
<ul>
<li>HTTP1.0의 문제점 해소 : 연속적인 응답 제공</li>
<li>빠른 속도와 Internet Protocol 설계에 최적화될 수 있도록 Cache 사용 Data를 압축해서 전달이 가능하도록 하여 전달하는 Data 양 감소</li>
</ul>
<p><img src="/images/net_4/HTTP1_1.PNG" alt="IMAGE"></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>HTTP Request / Response</p>
<ul>
<li>
<p>Request</p>
<ul>
<li>구조</li>
</ul>
<p><img src="/images/net_4/HTTP_request_struct.PNG" alt="IMAGE"></p>
<p><img src="/images/net_4/HTTP_request_struct1.PNG" alt="IMAGE"></p>
<p><img src="/images/net_4/HTTP_request_method.PNG" alt="IMAGE"></p>
<ul>
<li>GET / POST
<ul>
<li>GET : url에 포함하여 보낸다.</li>
<li>POST : body에 포함하여 보낸다.</li>
<li>URL vs URI : 요즘엔 URI(Uniform Resource Identifier)가 맞다.
<table>
<thead>
<tr>
<th>scheme</th>
<th align="center">://host[:port]</th>
<th align="right">[/path][?query]</th>
</tr>
</thead>
<tbody>
<tr>
<td>요청형식</td>
<td align="center">IP주소 :포트번호</td>
<td align="right">/파일경로 DB쿼리</td>
</tr>
<tr>
<td>ftp</td>
<td align="center">://IP주소:포트</td>
<td align="right">/파일경로 DB쿼리</td>
</tr>
<tr>
<td>http</td>
<td align="center">://(IP주소:포트/도메인주소)</td>
<td align="right">/파일경로 DB쿼리</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Response</p>
<ul>
<li>구조</li>
</ul>
<p><img src="/images/net_4/HTTP_response_struct.PNG" alt="IMAGE"></p>
<p><img src="/images/net_4/HTTP_response_struct1.PNG" alt="IMAGE"></p>
<p><img src="/images/net_4/HTTP_response_state.PNG" alt="IMAGE"></p>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">&lt;!-- RESTful API --&gt;
&lt;%@ page language=&#34;java&#34; contentType=&#34;text/html; charset=UTF-8&#34;
	pageEncoding=&#34;UTF-8&#34;%&gt;
	
&lt;%
	request.setCharacterEncoding(&#34;UTF-8&#34;);
	int result=0;
	int no1 = 0;
	int no2 = 0;
	try {
	no1 = Integer.parseInt(request.getParameter(&#34;num1&#34;));
	no2 = Integer.parseInt(request.getParameter(&#34;num2&#34;));
	no2 = Integer.parseInt(request.getParameter(&#34;kkk&#34;));
	} catch (Exception e) {
	
	}
%&gt;

&lt;%= no1 + no2 %&gt;
</code></pre></div>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.1237ff71925bb8625c97a9af8db4c54525258bedfd7c47493daaff723bea755e.js"></script>
  

  
  
  
    
  


</body>

</html>
