<!DOCTYPE html>
<html lang="UTF-8">

<head>
<meta charset="utf-8" />
<meta name="author" content="LaMelD" />
<meta name="description" content="Personal blog." />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.59.1" />

<link rel="canonical" href="https://lameld.github.io/post/kko_blind_2020_block/">
<meta property="og:title" content="[Programmers][Kakao Blind 2020] 블록 이동하기" />
<meta property="og:description" content="카카오 블라인드 테스트 2020 - 길 찾기 게임 문제 출처 : https://programmers.co.kr/learn/courses/30/lessons/60063
 문제 설명  아래의 왼쪽과 같이 board의 정보가 input으로 주어진다. 0과 1로 이루어진 N x N 크기의 지도에서 2 x 1 크기의 로봇을 (1, 1) 에서 (N, N) 까지 이동시킨다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lameld.github.io/post/kko_blind_2020_block/" />
<meta property="article:published_time" content="2019-11-27T11:22:43+09:00" />
<meta property="article:modified_time" content="2019-11-27T11:22:43+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[Programmers][Kakao Blind 2020] 블록 이동하기"/>
<meta name="twitter:description" content="카카오 블라인드 테스트 2020 - 길 찾기 게임 문제 출처 : https://programmers.co.kr/learn/courses/30/lessons/60063
 문제 설명  아래의 왼쪽과 같이 board의 정보가 input으로 주어진다. 0과 1로 이루어진 N x N 크기의 지도에서 2 x 1 크기의 로봇을 (1, 1) 에서 (N, N) 까지 이동시킨다."/>


<meta itemprop="name" content="[Programmers][Kakao Blind 2020] 블록 이동하기">
<meta itemprop="description" content="카카오 블라인드 테스트 2020 - 길 찾기 게임 문제 출처 : https://programmers.co.kr/learn/courses/30/lessons/60063
 문제 설명  아래의 왼쪽과 같이 board의 정보가 input으로 주어진다. 0과 1로 이루어진 N x N 크기의 지도에서 2 x 1 크기의 로봇을 (1, 1) 에서 (N, N) 까지 이동시킨다.">


<meta itemprop="datePublished" content="2019-11-27T11:22:43&#43;09:00" />
<meta itemprop="dateModified" content="2019-11-27T11:22:43&#43;09:00" />
<meta itemprop="wordCount" content="1236">



<meta itemprop="keywords" content="c&#43;&#43;,programmers,kakao blind 2020," />


<link rel="stylesheet" href="https://lameld.github.io/css/layout.css" />


<link rel="stylesheet" href="https://lameld.github.io/css/default-dark.css" />



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-153078485-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<title>


     [Programmers][Kakao Blind 2020] 블록 이동하기 

</title>

</head>


<body>



<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://lameld.github.io/">LaMelD&#39;s Dev Life</a>
    </div> 

    
    
    <a class="nav-item active" href="https://lameld.github.io/post/"><div class="nav-item-title">Posts</div></a>
    
    <a class="nav-item" href="https://lameld.github.io/categories/"><div class="nav-item-title">Category</div></a>
    
    <a class="nav-item" href="https://lameld.github.io/tags/"><div class="nav-item-title">Tags</div></a>
    
    <a class="nav-item" href="https://lameld.github.io/about/"><div class="nav-item-title">About</div></a>
    

  </nav>
    
</div>


</header>


<article class="post">
    <h1 class="title"> [Programmers][Kakao Blind 2020] 블록 이동하기 </h1>
    
<div class="tags">
    
      <div class="tag">
        <a href="https://lameld.github.io/tags/c&#43;&#43;">#c&#43;&#43;</a>
      </div>
    
      <div class="tag">
        <a href="https://lameld.github.io/tags/programmers">#programmers</a>
      </div>
    
      <div class="tag">
        <a href="https://lameld.github.io/tags/kakao-blind-2020">#kakao blind 2020</a>
      </div>
    
</div>

    
    <div class="content"> <h1>카카오 블라인드 테스트 2020 - 길 찾기 게임</h1>

<p>문제 출처 : <a href="https://programmers.co.kr/learn/courses/30/lessons/60063">https://programmers.co.kr/learn/courses/30/lessons/60063</a></p>

<ul>
<li>문제 설명

<ul>
<li>아래의 왼쪽과 같이 board의 정보가 input으로 주어진다.</li>
<li>0과 1로 이루어진 N x N 크기의 지도에서 <code>2 x 1</code> 크기의 로봇을 <code>(1, 1)</code> 에서 <code>(N, N)</code> 까지 이동시킨다.</li>
<li>시작은 아래의 왼쪽과 같이 시작한다.</li>
<li>로봇은 앞뒤 구분없이 움직일 수 있다.</li>
<li>로봇의 회전은 아래의 오른쪽과 같이 실행 할 수 있다.</li>
<li>로봇이 한칸 이동할 때 걸리는 시간은 1초이다.</li>
<li>90도 회전할 때 1초가 소요된다.</li>
</ul></li>
</ul>

<p><img src="https://lameld.github.io/images/moveblock1.jpg" width=80% height=80%></p>

<ul>
<li><p>문제 풀이</p>

<ul>
<li>기본적으로 탐색알고리즘은 다익스트라 알고리즘을 사용한다.</li>
<li>Memoization을 하기 위한 배열 visit을 생성한다
<br /></li>
</ul>

<blockquote>
<p>visit :: node</p>

<pre><code>struct node
{
    node() : left(false), right(false), top(false), bottom(false) {}

    //현재 위치와 왼쪽에 배치되어 있는가
    bool left;
    //현재 위치와 오른쪽에 배치되어 있는가
    bool right;
    //현재 위치와 위쪽에 배치되어 있는가
    bool top;
    //현재 위치와 아래쪽에 배치되어 있는가
    bool bottom;
};
</code></pre>

<p>visit :: 검색</p>

<pre><code>//로봇이 가로로 있을 경우
if (pos.p1.x == pos.p2.x)
{
    //로봇의 두 좌표가 visit 여부가 모두 false여야 진행한다.
    if (visit[pos.p1.x][pos.p1.y].left &amp;&amp; visit[pos.p2.x][pos.p2.y].right)
    {
        continue;
    }
    visit[pos.p1.x][pos.p1.y].left = true;
    visit[pos.p2.x][pos.p2.y].right = true;

    state = 0;
}
//로봇이 세로로 있을 경우
else
{
    //로봇의 두 좌표가 visit 여부가 모두 false여야 진행한다.
    if (visit[pos.p1.x][pos.p1.y].top &amp;&amp; visit[pos.p2.x][pos.p2.y].bottom)
    {
        continue;
    }
    visit[pos.p1.x][pos.p1.y].top = true;
    visit[pos.p2.x][pos.p2.y].bottom = true;

    state = 1;
}
</code></pre>
</blockquote>

<ul>
<li>좌표를 저장하기 위한 point와 pointset 구조체를 만든다.</li>
<li>시작 좌표를 기준으로 이동가능한 모든 좌표를 queue에 저장하고, 순차적으로 이동시켜 나아가 최적의 값을 구한다.
<br /></li>
</ul></li>
</ul>

<blockquote>
<p>Code</p>

<pre><code>#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

vector&lt;vector&lt;int&gt;&gt; B;

//for visit &amp; memo
struct node
{
	node() : left(false), right(false), top(false), bottom(false) {}

	//현재 위치와 왼쪽에 배치되어 있는가
	bool left;
	//현재 위치와 오른쪽에 배치되어 있는가
	bool right;
	//현재 위치와 위쪽에 배치되어 있는가
	bool top;
	//현재 위치와 아래쪽에 배치되어 있는가
	bool bottom;
};

struct point
{
	point() : x(0), y(0) {}
	int x;
	int y;

	void operator=(point a)
	{
		this-&gt;x = a.x;
		this-&gt;y = a.y;
	}
};

bool operator==(point a, point b)
{
	if (a.x == b.x &amp;&amp; a.y == b.y)
		return true;
	return false;
}

bool operator&lt;(point a, point b)
{
	if (a.x == b.x)
		return a.y &lt; b.y;

	if (a.y == b.y)
		return a.x &lt; b.y;
}

struct pointset
{
	point p1; //(n, n)과 상대적으로 가까운 것
	point p2; //(n, n)과 상대적으로 먼 것
};

bool operator==(pointset a, pointset b)
{
	if (a.p1 == b.p1 &amp;&amp; a.p2 == b.p2)
		return true;

	if (a.p1 == b.p2 &amp;&amp; a.p2 == b.p1)
		return true;

	return false;
}

struct W
{
	//최소값을 구하기 위한 값을 지정한다.
	int movecount;
	pointset pos;
};

//왼쪽, 오른쪽, 위쪽, 아래쪽 각각 이동이 가능한지 판단
bool moveleft(pointset pos, int&amp; n)
{
	if (0 &lt;= pos.p2.y - 1 &amp;&amp; B[pos.p1.x][pos.p1.y - 1] == 0 &amp;&amp; B[pos.p2.x][pos.p2.y - 1] == 0)
		return true;
	return false;
}
bool moveright(pointset pos, int&amp; n)
{
	if (pos.p1.y + 1 &lt; n &amp;&amp; B[pos.p1.x][pos.p1.y + 1] == 0 &amp;&amp; B[pos.p2.x][pos.p2.y + 1] == 0)
		return true;
	return false;
}
bool moveup(pointset pos, int&amp; n)
{
	if (0 &lt;= pos.p2.x - 1 &amp;&amp; B[pos.p1.x - 1][pos.p1.y] == 0 &amp;&amp; B[pos.p2.x - 1][pos.p2.y] == 0)
		return true;
	return false;
}
bool movedown(pointset pos, int&amp; n)
{
	if (pos.p1.x + 1 &lt; n &amp;&amp; B[pos.p1.x + 1][pos.p1.y] == 0 &amp;&amp; B[pos.p2.x + 1][pos.p2.y] == 0)
		return true;
	return false;
}

//state
//가로로 있을 때 :: 0
//세로로 있을 때 :: 1

//rotate p1 forward :: p1을 기준으로 시계방향으로 회전이동한다.
//rotate p2 reverse :: p2를 기준으로 반시계방향으로 회전이동한다.
bool rotate_p1_forward(pointset pos, int&amp; n, int state)
{
	if (state == 0)
	{
		if (0 &lt;= pos.p1.x - 1 &amp;&amp; B[pos.p2.x - 1][pos.p2.y] == 0 &amp;&amp; B[pos.p1.x - 1][pos.p1.y] == 0)
			return true;
	}
	else
	{
		//p1, p2가 스왑되어 들어가야함
		if (pos.p1.y + 1 &lt; n &amp;&amp; B[pos.p2.x][pos.p2.y + 1] == 0 &amp;&amp; B[pos.p1.x][pos.p1.y + 1] == 0)
			return true;
	}

	return false;
}
bool rotate_p1_reverse(pointset pos, int&amp; n, int state)
{
	if (state == 0)
	{
		//p1, p2가 스왑되어 들어가야함
		if (pos.p1.x + 1 &lt; n &amp;&amp; B[pos.p2.x + 1][pos.p2.y] == 0 &amp;&amp; B[pos.p1.x + 1][pos.p1.y] == 0)
			return true;
	}
	else
	{
		if (0 &lt;= pos.p1.y - 1 &amp;&amp; B[pos.p2.x][pos.p2.y - 1] == 0 &amp;&amp; B[pos.p1.x][pos.p1.y - 1] == 0)
			return true;
	}

	return false;
}
bool rotate_p2_forward(pointset pos, int&amp; n, int state)
{
	if (state == 0)
	{
		if (pos.p2.x + 1 &lt; n &amp;&amp; B[pos.p1.x + 1][pos.p1.y] == 0 &amp;&amp; B[pos.p2.x + 1][pos.p2.y] == 0)
			return true;
	}
	else
	{
		//p1, p2가 스왑되어 들어가야함
		if (0 &lt;= pos.p2.y - 1 &amp;&amp; B[pos.p1.x][pos.p1.y - 1] == 0 &amp;&amp; B[pos.p2.x][pos.p2.y - 1] == 0)
			return true;
	}

	return false;
}
bool rotate_p2_reverse(pointset pos, int&amp; n, int state)
{
	if (state == 0)
	{
		//p1, p2가 스왑되어 들어가야함
		if (0 &lt;= pos.p2.x - 1 &amp;&amp; B[pos.p1.x - 1][pos.p1.y] == 0 &amp;&amp; B[pos.p2.x - 1][pos.p2.y] == 0)
			return true;
	}
	else
	{
		if (pos.p2.y + 1 &lt; n &amp;&amp; B[pos.p1.x][pos.p1.y + 1] == 0 &amp;&amp; B[pos.p2.x][pos.p2.y + 1] == 0)
			return true;
	}

	return false;
}

void Swap(point&amp; a, point&amp; b)
{
	point tmp;
	tmp = a;
	a = b;
	b = tmp;
}

int solution(vector&lt;vector&lt;int&gt;&gt; board)
{
	int n = board.size();
	vector&lt;vector&lt;node&gt;&gt; visit(n, vector&lt;node&gt;(n));
	B = board;
	
	//이동을 저장하기 위한 공간
	queue&lt;W&gt; q;

	pointset pos;
	pos.p1.y = 1;
	W pushing;
	pushing.movecount = 0;
	pushing.pos = pos;

	q.push(pushing);
	int ret = 0;

	//다익스트라 알고리즘을 기반
	while (!q.empty())
	{
		pos = q.front().pos;
		ret = q.front().movecount;
		q.pop();

		//최초에 (n, n)에 도달한 movecount를 리턴한다.
		if (pos.p1.x == (n - 1) &amp;&amp; pos.p1.y == (n - 1))
		{
			return ret;
		}

		int state = -1;

		//visit의 여부를 확인하여 이동 가능한 모든 구역을 조사
		//조사 후에 queue에 넣는다

		//가로로 있을 경우
		if (pos.p1.x == pos.p2.x)
		{
			if (visit[pos.p1.x][pos.p1.y].left &amp;&amp; visit[pos.p2.x][pos.p2.y].right)
			{
				continue;
			}
			visit[pos.p1.x][pos.p1.y].left = true;
			visit[pos.p2.x][pos.p2.y].right = true;

			state = 0;
		}
		//세로로 있을 경우
		else
		{
			if (visit[pos.p1.x][pos.p1.y].top &amp;&amp; visit[pos.p2.x][pos.p2.y].bottom)
			{
				continue;
			}
			visit[pos.p1.x][pos.p1.y].top = true;
			visit[pos.p2.x][pos.p2.y].bottom = true;

			state = 1;
		}

		//왼쪽, 오른쪽, 위쪽, 아래쪽 각각 이동이 가능하다면 이동한다.
		if (moveleft(pos, n))
		{
			pushing.pos = pos;
			pushing.pos.p1.y--;
			pushing.pos.p2.y--;
			pushing.movecount = ret + 1;
			q.push(pushing);
		}
		if (moveright(pos, n))
		{
			pushing.pos = pos;
			pushing.pos.p1.y++;
			pushing.pos.p2.y++;
			pushing.movecount = ret + 1;
			q.push(pushing);
		}
		if (moveup(pos, n))
		{
			pushing.pos = pos;
			pushing.pos.p1.x--;
			pushing.pos.p2.x--;
			pushing.movecount = ret + 1;
			q.push(pushing);
		}
		if (movedown(pos, n))
		{
			pushing.pos = pos;
			pushing.pos.p1.x++;
			pushing.pos.p2.x++;
			pushing.movecount = ret + 1;
			q.push(pushing);
		}

		if (rotate_p1_forward(pos, n, state))
		{
			if (state == 0)
			{
				pushing.pos = pos;
				pushing.pos.p2.x--;
				pushing.pos.p2.y++;
				pushing.movecount = ret + 1;
				q.push(pushing);
			}
			else
			{
				//p1, p2가 스왑되어 들어간다.
				//상대적으로 종료지점과 가까운 point를 p1으로 한다.
				pushing.pos = pos;
				pushing.pos.p2.x++;
				pushing.pos.p2.y++;
				Swap(pushing.pos.p1, pushing.pos.p2);
				pushing.movecount = ret + 1;
				q.push(pushing);
			}
		}

		if (rotate_p1_reverse(pos, n, state))
		{
			if (state == 0)
			{
				//p1, p2가 스왑되어 들어간다.
				//상대적으로 종료지점과 가까운 point를 p1으로 한다.
				pushing.pos = pos;
				pushing.pos.p2.x++;
				pushing.pos.p2.y++;
				Swap(pushing.pos.p1, pushing.pos.p2);
				pushing.movecount = ret + 1;
				q.push(pushing);
			}
			else
			{
				pushing.pos = pos;
				pushing.pos.p2.x++;
				pushing.pos.p2.y--;
				pushing.movecount = ret + 1;
				q.push(pushing);
			}
		}

		if (rotate_p2_forward(pos, n, state))
		{
			if (state == 0)
			{
				pushing.pos = pos;
				pushing.pos.p1.x++;
				pushing.pos.p1.y--;
				pushing.movecount = ret + 1;
				q.push(pushing);
			}
			else
			{
				//p1, p2가 스왑되어 들어간다.
				//상대적으로 종료지점과 가까운 point를 p1으로 한다.
				pushing.pos = pos;
				pushing.pos.p1.x--;
				pushing.pos.p1.y--;
				Swap(pushing.pos.p1, pushing.pos.p2);
				pushing.movecount = ret + 1;
				q.push(pushing);
			}
		}

		if (rotate_p2_reverse(pos, n, state))
		{
			if (state == 0)
			{
				//p1, p2가 스왑되어 들어간다.
				//상대적으로 종료지점과 가까운 point를 p1으로 한다.
				pushing.pos = pos;
				pushing.pos.p1.x--;
				pushing.pos.p1.y--;
				Swap(pushing.pos.p1, pushing.pos.p2);
				pushing.movecount = ret + 1;
				q.push(pushing);
			}
			else
			{
				pushing.pos = pos;
				pushing.pos.p1.x--;
				pushing.pos.p1.y++;
				pushing.movecount = ret + 1;
				q.push(pushing);
			}
		}
	}

	//도달하지 못하였을 경우 0을 리턴한다.
	return 0;
}
</code></pre>
</blockquote>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
      <div class="tag">
        <a href="https://lameld.github.io/tags/c&#43;&#43;">#c&#43;&#43;</a>
      </div>
    
      <div class="tag">
        <a href="https://lameld.github.io/tags/programmers">#programmers</a>
      </div>
    
      <div class="tag">
        <a href="https://lameld.github.io/tags/kakao-blind-2020">#kakao blind 2020</a>
      </div>
    
</div>

    <div class="date"> 27 Nov 2019 </div>
  </div>

</footer>


  


</article>

  <footer>

  <div class="social-links-footer">

  
  <a href="mailto:wqe014@gmail.com"><div class="social-link">Email</div></a>
  

  
  <a href="https://github.com/lameld" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  
  <a href="https://instagram.com/sangjoooooooooooon" target="_blank"><div class="social-link">instagram</div></a>
  

  

  <div class="social-link">
  <a href="https://lameld.github.io/index.xml" target="_blank">RSS</a>
  </div>

</div>


  <div class="copyright">  </div>

  <div class="poweredby">
    Powered by <a href="https://gohugo.io/">Hugo</a>.
  </div>

  </footer>

</div> 

</body>
</html>

